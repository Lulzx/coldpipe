<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Register - Coldpipe</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@tabler/core@1.4.0/dist/css/tabler.min.css">
</head>
<body class="d-flex flex-column bg-white">
  <div class="page page-center">
    <div class="container container-tight py-4">
      <div class="text-center mb-4">
        <h1>Coldpipe</h1>
        <p class="text-muted">Create your account with a passkey</p>
      </div>
      <div class="card card-md">
        <div class="card-body">
          <h2 class="card-title text-center mb-4">Register</h2>
          <div id="error-msg" class="alert alert-danger d-none"></div>
          <div class="mb-3">
            <label class="form-label">Username</label>
            <input type="text" id="username" class="form-control" placeholder="Enter your username" autofocus required>
          </div>
          <div class="form-footer">
            <button id="register-btn" class="btn btn-primary w-100" type="button">
              Register with Passkey
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
<script>
function b64urlToBuffer(b64url) {
  const pad = b64url.length % 4;
  if (pad) b64url += '='.repeat(4 - pad);
  const bin = atob(b64url.replace(/-/g, '+').replace(/_/g, '/'));
  const buf = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) buf[i] = bin.charCodeAt(i);
  return buf.buffer;
}
function bufferToB64url(buf) {
  const bytes = new Uint8Array(buf);
  let bin = '';
  for (const b of bytes) bin += String.fromCharCode(b);
  return btoa(bin).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}
document.getElementById('register-btn').addEventListener('click', async () => {
  const errorEl = document.getElementById('error-msg');
  errorEl.classList.add('d-none');
  const username = document.getElementById('username').value.trim();
  if (!username) { errorEl.textContent = 'Username is required'; errorEl.classList.remove('d-none'); return; }
  try {
    const optRes = await fetch('/auth/register/begin', {
      method: 'POST', headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({username})
    });
    if (!optRes.ok) { const e = await optRes.json(); throw new Error(e.error || 'Failed'); }
    const options = await optRes.json();
    options.challenge = b64urlToBuffer(options.challenge);
    options.user.id = b64urlToBuffer(options.user.id);
    if (options.excludeCredentials) {
      options.excludeCredentials = options.excludeCredentials.map(c => ({...c, id: b64urlToBuffer(c.id)}));
    }
    const credential = await navigator.credentials.create({publicKey: options});
    const body = {
      id: credential.id,
      rawId: bufferToB64url(credential.rawId),
      type: credential.type,
      response: {
        attestationObject: bufferToB64url(credential.response.attestationObject),
        clientDataJSON: bufferToB64url(credential.response.clientDataJSON),
      }
    };
    if (credential.response.getTransports) {
      body.response.transports = credential.response.getTransports();
    }
    const verRes = await fetch('/auth/register/complete', {
      method: 'POST', headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(body)
    });
    const result = await verRes.json();
    if (result.ok) { window.location.href = result.redirect || '/'; }
    else { throw new Error(result.error || 'Registration failed'); }
  } catch (err) {
    errorEl.textContent = err.message || 'Registration failed';
    errorEl.classList.remove('d-none');
  }
});
</script>
</body>
</html>
